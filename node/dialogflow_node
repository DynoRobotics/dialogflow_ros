#!/usr/bin/env python
#
# License: BSD
#   https://raw.githubusercontent.com/samiamlabs/dyno/master/LICENCE
#

import rospy
import uuid
import dialogflow_v2 as dialogflow

import std_msgs.msg as std_msgs
from dialogflow_ros.msg import QueryResult, AudioChunk
from std_srvs.srv import Empty, EmptyResponse

from collections import deque


class DialogflowNode:
    def __init__(self):
        rospy.init_node('dialogflow_node')

        self.project_id = rospy.get_param('~project_id', 'dynotestsample')
        self.session_id = rospy.get_param('~session_id', uuid.uuid4())
        self.default_language = rospy.get_param('~default_language', 'en-US')

        self.session_client = dialogflow.SessionsClient()
        self.session = self.session_client.session_path(self.project_id, self.session_id)
        rospy.loginfo('Session path: {}\n'.format(self.session))

        self.audio_chunk_queue = deque()
        self.max_queue_size = 100

        # Note: hard coding audio_encoding and sample_rate_hertz for simplicity.
        audio_encoding = dialogflow.enums.AudioEncoding.AUDIO_ENCODING_LINEAR_16
        sample_rate_hertz = 16000
        self.audio_config = dialogflow.types.InputAudioConfig(
            audio_encoding=audio_encoding, language_code=self.default_language,
            sample_rate_hertz=sample_rate_hertz)

        self.query_result_pub = rospy.Publisher('query_result', QueryResult, queue_size=10)

        rospy.Subscriber('text', std_msgs.String, self.text_callback)
        rospy.Subscriber('audio', AudioChunk, self.audio_callback)

    def text_callback(self, text_msg):
        query_result = self.detect_intent_text(text_msg.data)

        query_result_msg = QueryResult()
        query_result_msg.transcript = text_msg.data
        query_result_msg.fulfillment_text = query_result.fulfillment_text.encode('utf-8')
        query_result_msg.intent_detection_confidence = query_result.intent_detection_confidence
        query_result_msg.intent = query_result.intent

        self.query_result_pub.publish(query_result_msg)

    def audio_callback(self, audio_chunk_msg):
        if len(self.audio_chunk_queue) < self.max_queue_size:
            self.audio_chunk_queue.append(audio_chunk_msg.data)
        else:
            rospy.logwarn("Audio chunk queue if full, clearing!")
            self.audio_chunk_queue = deque()

    def detect_intent_text(self, text):

        text_input = dialogflow.types.TextInput(text=text, language_code=self.default_language)
        query_input = dialogflow.types.QueryInput(text=text_input)
        response = self.session_client.detect_intent(session=self.session, query_input=query_input)

        rospy.loginfo('=' * 20)
        rospy.loginfo('Query text: {}'.format(response.query_result.query_text))
        rospy.loginfo('Detected intent: {} (confidence: {})\n'.format(
            response.query_result.intent.display_name,
            response.query_result.intent_detection_confidence))
        rospy.loginfo('Fulfillment text: {}\n'.format(
            response.query_result.fulfillment_text))
        return response.query_result

    def detect_intent_stream(self):
        requests = self.audio_stream_request_generator()
        responses = self.session_client.streaming_detect_intent(requests)

        rospy.loginfo('=' * 20)
        for response in responses:
            rospy.loginfo('Intermediate transcript: "{}".'.format(
                    response.recognition_result.transcript.encode('utf-8')))

        # Note: The result from the last response is the final transcript along
        # with the detected content.
        query_result = response.query_result

        rospy.loginfo('=' * 20)
        rospy.loginfo('Query text: {}'.format(query_result.query_text))
        rospy.loginfo('Detected intent: {} (confidence: {})\n'.format(
            query_result.intent.display_name,
            query_result.intent_detection_confidence))
        rospy.loginfo('Fulfillment text: {}\n'.format(
            query_result.fulfillment_text.encode('utf-8')))

    def audio_stream_request_generator(self):
        query_input = dialogflow.types.QueryInput(audio_config=self.audio_config)

        # The first request contains the configuration.
        yield dialogflow.types.StreamingDetectIntentRequest(
            session=self.session, query_input=query_input)

        # Here we are reading small chunks of audio from a dequeue
        while True:
            # Wait for more chunks to allow continious streaming
            if len(self.audio_chunk_queue) == 0:
                rospy.sleep(0.1)
                if len(self.audio_chunk_queue) == 0:
                    break

            chunk = self.audio_chunk_queue.popleft()

            # The later requests contains audio data.
            yield dialogflow.types.StreamingDetectIntentRequest(input_audio=chunk)

    def update(self):
        if len(self.audio_chunk_queue) > 0:
            self.detect_intent_stream()


if __name__ == '__main__':
    dialogflow_node = DialogflowNode()
    while not rospy.is_shutdown():
        dialogflow_node.update()
        rospy.sleep(0.1)
